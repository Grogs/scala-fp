<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <style>
      .reveal .footer {
        position: absolute;
        bottom: 1em;
        left: 1em;
        font-size: 0.7em;
      }

      /*Theme overrides*/
        .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
          text-transform: none;
        }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class='footer'>
        <a href="https://grogs.github.io/scala-fp">grogs.github.io/scala-fp</a>
      </div>
      <div class="slides">
        <section data-markdown data-separator="^~~~~" data-separator-vertical="^~" data-notes="^Note:">
          <script type="text/template">
          ## Functional Programming with Scala  

          ### Lesson 1

          ~~~~

          ## Introductions
          * What's your name? 
          * Where do you work?  
          * What are your experiences with the following?: 
            - Scala
            - functional programming
          * What are you looking to get from the course?

          ~~~~

          ## Course Plan

          ~

          Learn about Functional programming...
          ~
          ...in Scala
          ~
          We'll look at what's baked into the language
          ~
          We'll look at the FP ecosystem (libraries - mostly Typelevel)
          ~
          FP is a mindset/approach to programming.

          You can apply this approach in Java, Python, JavaScript, etc.
          ~~~~
          What is functional programming?
          ~
          At a high level: Functional programming is a style of programming which models computations as the evaluation of expressions

          In contrast with imperative programming where programs are composed of statements  which change global state when executed.  <!-- .element: class="fragment" data-fragment-index="1" -->
          ~
          Functional programming has been around a long time

          Lambda calculus in 1930s and then Lisp in 1950s.
          ~
          Lisp has been around for ~60 years.  

          Why are people only excited about this now?
          ~
          Computers were slow.  
          ~
          At the time there were two directions that the design and implementation of programming languages:  
          * Start from the Von Neumann Architecture and add abstraction.
          * Start from Mathematics and remove abstraction.

          Note: Von Neumann base: FORTRAN -> ALGOL -> BCPL -> C
          ~
          Lisp was too slow.  

          Imperative won.
          Note:
          Computer couldn't handle that much abstraction.
          ~
          But now computer are fast. 
          Note: 
          * Memory is cheap.
          * Von Neumann models a single machine, that style of programming doesn't work when distributing computation
          ~~~~
          Some Concepts, Idioms and Philosophy of FP
          ~
          Immutability.  

          Once you create something, you don't modify it.

          Note: 
          * It's threadsafe. 
          * Not as expensive as it used to.
          * Show some stuff in Scala.
            * val vs var
            * collections. immutable by default. AKA Persistent data structures
            * case classes
              * val is the default
              * copy method
                *maybe mention lenses
          ~
          Functions. In the pure mathematical sense. Or referentially transparent.

          Why? <!-- .element: class="fragment" data-fragment-index="1" -->

          Easier to reason about and compose<!-- .element: class="fragment" data-fragment-index="2" -->

          Note:
          * Referencial transparency: A given invocation of a pure function can always be replaced by its result
          * They take input and produce an output. No side effects  
          * Scala doesn't enforce this. Other languages do, e.g. Haskell.
          * If immutable input/output:
            * Ordering requirements are more explicit. (Don't hide a lookup to the DB, pass the retrieved records in)
            * You get concurrency for free.
          * Easier to test. If all your inputs are there explicitly in the type signature, you provide them
          ~
          First class functions. You can pass them around.

          Note:
          * enable composition. changing functions. Scala has `andThen`
          * Show the difference between methods and functions in Scala REPL/ammonite:
          ```
          grogs-grogs@ def method(i: Int): Int = i \* 2
          defined function method
          grogs-grogs@ val function = (i: Int) => i \* 2
          function: Int => Int = <function1>
          ```
            * Scala really hides this from you. We can call `(1 to 3).foreach(println)`. `println` is a method, but a function will be created for you.
          ~
          Totality.  

          Functions should be total.  

          Every input has a corresponding output.


          Note:
          * ##DEMO
          * Scala doesn't enforce this. But it does have partial functions, and the compile identies not exhaustive functions
          * Example of non-total functions
          ~
          Decouple data from behaviour

          In OO, we encapsulate an object's state and behaviour together.<!-- .element: class="fragment" data-fragment-index="1" -->

          In FP, we have immutable data and pure functions. No need to encapsulate/restrict usage.<!-- .element: class="fragment" data-fragment-index="2" -->
          ~
          Types vs Classes. 
          
          Classes in the OO sense are about encapulation.

          Types are about input and output.  

          Confusingly, in Scala we model types with classes.<!-- .element: class="fragment" data-fragment-index="1" -->

          Note:
          * Well Algebraic Data Types
          * *Demo of sealed traits here. Explain union types, sum types. Mention shapeless encoding?* 
          * You can still have methods on classes. But they're pure functions which don't mutate. They could go anywhere (e.g. copy/toString/hashcode methods).
          ~
          Types as documentation

          Note:
          * Input and output types serve as documentation
          * Monads? Maybe mention Slick 3 DBIO.
          * Should I mention typeclasses here?*
          <!-- * *Ties into DDD* ??? -->
          ~
          Push side effects to the edge of your system
          Note: Mention Slick DBIO again
          ~
          Parameterize everything / Make everything as generic as possible.

          This enables maximum re-use/composition.  

          <div>
          <br />
          But this quickly needs to general abstract nonsense. AKA category theory.  

          See [You Could Have Invented Monads! (And Maybe You Already Have.)](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)  
          </div><!-- .element: class="fragment" data-fragment-index="1" -->
          <!-- ~ -->
          <!-- Partial functions/currying -->
          ~~~~
          scala labs
          ~
          A set of exercises to learn Scala.

          Today, let's get setup and try to complete ListManipulationExercise02.
          ~
          * Read through https://scala-labs.github.io/getting-started.html.
          * Get the tests in ListManipulationExercise02 running in IDE
          * Make them pass
          
          ~~~~

          ###Credits / Further Reading
          These resources were helpful when I put together these slides:
          * ['Functional Programming should be your #1 priority for 2015' by Ju Gon√ßalves](https://medium.com/@jugoncalves/functional-programming-should-be-your-1-priority-for-2015-47dd4641d6b9#.6h0qyo7fo)
          * [https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming)
          * [Functional Programming: Concepts, Idioms and Philosophy](https://hkupty.github.io/2016/Functional-Programming-Concepts-Idioms-and-Philosophy/)
          * ['Function Programming Patterns' by Scott Wlaschin](http://www.slideshare.net/ScottWlaschin/fp-patterns-ndc-london2014)
          </script>         
        </section>


         <!--  ~~~~

          Lots of FP research has been done since.

          * Persistent data structures

          If you're using Java, you can still apply these techniques. 

          But the compiler won't do as much work for you. The syntax won't be as nice, and less compile time safety.

          ~

          Let's start by defining functional programming

          ~~~~

          Functional programming is a style of programming where functions don't have side effects. 

          ~

          ###Functional vs Imperative 
          ####AKA Pure vs Impure, or Immutable vs Mutable 

          <br /><br />
          In functional programming we compose programs using __expressions__.
          
          This is in contrast to composing __statements__.  

          Note:
          Statements have side effects, expressions return a value.

          ~
          
          Functions compose

          ~

          Example: Print the sum the numbers between 1 and 10


          ~
          In Java:

          ```
          int result = 0;
          for(int i = 0 ; i < 10; i++) {
            result += i;
          } 
          System.out.println(result)

          ```
          ~

          <div>
          <code>
          <pre><mark>int result = 0;</mark>
          for(int i = 0 ; i < 10; i++) {
            result += i;
          } 
          System.out.println(result)

          </code></pre>
          </div>
          ~




          In Scala:
          ```
          println((1 to 10).sum)
          ```
          Note: Expressions to generate the sum, then a statement to print it.
          ~~~~

          Concepts to cover:
            The importance of types and strong/static typing
            'Shape' of types & functions



          What is FP?

          Why is it worthwhile?
            Parallelism
            Easier to reason about
            Composable/Re-usable -->

<!--        <section>
          <h1>Code</h1>
          <p>We won't write any code today. Instead we'll look at the code we already have.</p>
          <p>Run your copy of the example 'play-scala' project</p>
          <ul>
            <li>cd play-scala</li>
            <li>sbt run</li>
            <li>open http://localhost:9000</li>
          </ul>
        </section>
 -->      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
